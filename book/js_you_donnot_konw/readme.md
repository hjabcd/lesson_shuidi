
`你不知道的javascript`

# 第一章：作用域
1. 传统编译语言步骤：
  `分词/词法分析`：这个过程会将由字符组成的自负床分解成有意义的代码块，这个代码块被称为‘词法单元’。如 var a = 2;会被分解成：var,a,=,2,;。空格是否会被当作词法单元，取决于空格在这门语言中是否有意义。
  `解析/语法分析`：将单元快转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。成为‘抽象语法树’
  `代码生成`:将AST转换成可执行代码的过程称为代码生成。（AST：抽象语法树）既有某种方法可以将var a = 2;的AST转换成一组机器指令，用来创建一个叫做a的变量，并将一个值存储在a中。
2. 理解作用域
   引擎 编译器 `作用域`（负责收集并维护由所有声明的标识符组成的一系列查询，确定执行代码标识符的访问权限）
   编译器的编译过程：首先编译器会在当前的作用域声明一个变量，然后运行时引擎会在作用域中查找该变量如果能找到将对它进行赋值。
3. 编译器查询类型
   LHS：左侧进行LHS查询，赋值操作的目标(变量赋值)
   RHS：右侧进行RHS查询，赋值操作的源头(获取变量)
4. 异常
   RHS异常抛出ReferenceType(非严格模式)
   LHS异常抛出TypeError(严格模式)
总结：`作用域是一套规则，确定在何处以及如何查找标量` 

# 第二章：词法作用域
    作用域共有两种主要的工作模型：词法作用域、动态作用域
1. 词法阶段
   `词法作用域`：由你在写代码时将变量和块作用域写在哪里来决定的， 因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。
   示例：function foo(a) {
                var b = a * 2;
                    function bar(c) {
                    console.log( a, b, c );
                    } 
                    bar( b * 3 );
                } 
                    foo( 2 ); // 2, 4, 12
   1. function和foo()包含着整个全局作用域， 其中只有一个标识符： foo
   2. foo函数内部包含着 foo 所创建的作用域， 其中有三个标识符： a、 bar 和 b。
   3. bar函数内部包含着 bar 所创建的作用域， 其中只有一个标识符： c。
   注：作用域气泡由其对应的作用域块代码写在哪里决定， 它们是逐级包含的。 
      
   `查找`：作用域气泡的结构和互相之间的位置关系给引擎提供了足够的位置信息， 引擎用这些信息来查找标识符的位置。 首先从最内部的作用域查找。如果直接查找到需要的变量就不会再去外部进行查找。
   注：作用域查找会在找到第一个匹配的标识符时停止。 在多层的嵌套作用域中可以定义同名的标识符， 这叫作“遮蔽效应”（内部的标识符“遮蔽” 了外部的标识符）。
    `window.a`: 通过这种技术可以访问那些被同名变量所遮蔽的全局变量。 但非全局的变量如果被遮蔽了， 无论如何都无法被访问到。
2. 欺骗词法
    欺骗词法作用域会导致性能下降。所有不推荐使用
    `eval`: eval(..) 函数可以接受一个字符串为参数，可以在你写的代码中用程序生成代码并运行， 就好像代码是写在那个位置的一样。(词法期)
    示例：function foo(str, a) {
                            eval( str ); // 欺骗！
                            console.log( a, b );
                            }
                            var b = 2;
                            foo( "var b = 3;", 1 ); // 1, 3
    注：eval创建一个新的变量b掩盖了b=2, "use strict";在严格模式下则没有用。
    `with`: with 通常被当作重复引用同一个对象中的多个属性的快捷方式， 可以不需要重复引用对象本身。？？？？有点迷
    示例：function foo(obj) {
                        with (obj) {
                        a = 2;
                        }
                    }
                        var o1 = {
                        a: 3
                    };
                        var o2 = {
                        b: 3
                    };
                        foo( o1 );
                        console.log( o1.a ); // 2
                        foo( o2 );
                        console.log( o2.a ); // undefined
                        console.log( a ); // 2——不好， a 被泄漏到全局作用域上了！ //with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域， 因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。
    注：严格模式下也没有用。
3. 性能
    JavaScript 引擎会在编译阶段进行数项的性能优化。 其中有些优化依赖于能够根据代码的词法进行静态分析， 并预先确定所有变量和函数的定义位置， 才能在执行过程中快速找到标识符。
4. 总结：词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。 JavaScript 中有两个机制可以“欺骗” 词法作用域： eval(..) 和 with。 前者可以对一段包含一个或多个声明的“代码” 字符串进行演算， 并借此来修改已经存在的词法作用域（在运行时）。 后者本质上是通过将一个对象的引用当作作用域来处理， 将对象的属性当作作用域中的标识符来处理， 从而创建了一个新的词法作用域（同样是在运行时）。(都不推荐使用)
